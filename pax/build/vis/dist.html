<!DOCTYPE html>
<html>
<head>
	<title>Passenger Arrival Distribution</title>
	<script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/1.1.0/d3-legend.js"></script>
	<script src="../js/lib/numeric-1.2.6.js"></script>
	<script src="data.js"></script>
	<style type="text/css">
	
		svg {
			padding: 50px 0px 50px 50px;
		}

		body {
			font: 10px sans-serif;
		}

		path {
			fill: none;
			stroke-width: 2px;
		}

	</style>
</head>
<body>

	<script type="text/javascript">

		var outerWidth = 1000,
			outerHeight = 500,
			margin = { left: 50, top: 50, right: 50, bottom: 50};

		var xColumn = "x",
			yColumn = "y",
			colorColumn = "type";

		var innerWidth = outerWidth - margin.left - margin.right,
			innerHeight = outerHeight - margin.top - margin.bottom;

		var svg = d3.select("body").append("svg")
				.attr("width", outerWidth)
				.attr("height", outerHeight);

		var g = svg.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		var xAxisG = g.append("g")
				.attr("class", "x axis")
				.attr("transform", "translate(0,"+ innerHeight + ")");

		var yAxisG = g.append("g")
				.attr("class", "y axis")

		var colorLegendG = g.append("g")
				.attr("class", "color-legend")
				.attr("transform", "translate(500,0)");

		var xScale = d3.scale.linear().range([0,innerWidth]),
			yScale = d3.scale.linear().range([innerHeight, 0]),
			colorScale = d3.scale.ordinal()
				.range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

		var xAxis = d3.svg.axis().scale(xScale).orient("bottom")
				.outerTickSize(0)
				.ticks(20);

		var yAxis = d3.svg.axis().scale(yScale).orient("left")
				.outerTickSize(0);

		var line = d3.svg.line()
			.interpolate("basis") //monotone // step-before
			.x(function(d) { return xScale(d[xColumn]); })
			.y(function(d) { return yScale(d[yColumn]); })

		var colorLegend = d3.legend.color()
				.scale(colorScale)
				.shapePadding(3)
				.shapeWidth(15)
				.shapeHeight(15)
				.labelOffset(10)

		function makeFitFn(pts, order) {
		  
		  pts = pts.filter(function(pt) {
		    return pt.y > 0;
		  })
		  console.log(pts);
		  var  xArr = pts.map(function(pt) {
		    return pt.x;
		  })
		  var yArr = pts.map(function(pt) {
		    return pt.y;
		  })
		  var xMatrix = [];
		  var xTemp = [];
		  var yMatrix = numeric.transpose([yArr]);

		  for (j=0;j<xArr.length;j++)
		  {
		      xTemp = [];
		      for(i=0;i<=order;i++)
		      {
		          xTemp.push(1*Math.pow(xArr[j],i));
		      }
		      xMatrix.push(xTemp);
		  }
		  var xMatrixT = numeric.transpose(xMatrix);
		  var dot1 = numeric.dot(xMatrixT,xMatrix);
		  var dotInv = numeric.inv(dot1);
		  var dot2 = numeric.dot(xMatrixT,yMatrix);
		  var solution = numeric.dot(dotInv,dot2);

		  var fn = function(x) {
		    var y = 0;
		    for (var i=0; i<solution.length; i++) {
		      y+= solution[i] * Math.pow(x, i);
		    }
		    return y > 0 ? y : 0;
		    
		  }
		  return fn;
		}


		function render(data) {

			var nested = Object.keys(data).map(function(k) {
				return {
					"name" : k,
					"profiles" : Object.keys(data[k]).map(function(nk) {
						return {
							"di": nk,
							"values": Object.keys(data[k][nk]).map(function(nnk) {


								function median(arr) {
									return arr.length % 2 !== 0 ?
										arr[Math.ceil(arr.length / 2)] : 
										( arr[arr.length / 2] + arr[(arr.length / 2) + 1] ) / 2 ;
								}
								function iqr(arr) {
									if (arr.length !== 0) {
										var m = Math.ceil(arr.length / 2);
									}
									else {
										var m = arr.length / 2;
									}
									var s1 = arr.slice(0,m);
									var s2 = arr.slice(m)
									return [median(s1), median(s2)]
								}
								function normalPdf(mean, sd) {

									return function(x) {
										
										var r = 1 / (sd * Math.sqrt(2 * Math.PI) )
										var num = Math.pow( ( x - mean ), 2 )
										var denom = ( 2 * Math.pow(sd, 2) )
										return r * Math.exp( - num / denom );

									}
								}
								function logNormalPdf(mean, sd) {
									
									return function(x) {
										
										var r = 1 / (x * sd * Math.sqrt(2 * Math.PI) )
										var num = Math.pow( ( Math.log(x) - mean ), 2 )
										var denom = ( 2 * Math.pow(sd, 2) )
										return r * Math.exp( - num / denom );

									}
								}
								
								var profile = data[k][nk][nnk],
									spl = nnk.split('.'),
									_v = [];

								profile.type = [k,spl.slice(1).join('.')].join('.');
								profile.values = Object.keys(profile.dist).map(function(d) {
									return { 
										x : +d, 
										y : +profile.dist[d] 
									}; 
								});

								if (profile.values.length === 0) return [];

								profile.count = 0
								profile.mode = profile.values[0];
								profile.sum = profile.values.reduce(function(a,b) {
									profile.count+= b.y;
									if (b.y > profile.mode.y) profile.mode = b;
									for (var i=0;i<b.y;i++) _v.push(b.x);
									return a + (b.x * b.y);
								},0);
								profile.mean = profile.sum / profile.count;
								profile.mode = profile.mode.x;

								_v = _v.sort(function(a,b) { return a-b; });

								profile.median = median(_v);
								profile.varience = _v.reduce(function(total,n) {
									return total + Math.pow(n-profile.mean, 2);
								},0) / profile.count;
								profile.sd = Math.pow(profile.varience, 0.5);

								profile.func = normalPdf(profile.mean, profile.sd)


								var test = 100;

								console.log( test, "-------> ", profile.func(test))
								return profile;
							})
						}
					})
				}
			});

			var flattened = nested.reduce(function(l,d) {
				for (var i=0; i<d.profiles.length; i++) {
					for (var j=0; j<d.profiles[i].values.length; j++) {
						l.push(d.profiles[i].values[j])
					}
				}
				return l;
			},[]).slice(0,6)

			var yDom = flattened.map(function(d) {
				return Object.keys(d.dist).map(function(k){
					return +d.dist[k];
				})
			}).reduce(function(l,d) {
				return l.concat(d);
			},[])

			xScale.domain( d3.extent([0,360]));
			yScale.domain( d3.extent([0,.01]));
			colorScale.domain( flattened.map( function(d) {	return d[colorColumn]; }));

			var lines = g.selectAll(".type")
				.data(flattened)
				.enter()
					.append("g")
					.attr("class", "type");

			lines.append("path")
				.attr("class", "line")
				.attr("d", function(d) {
					return line(d.values.map(function(di) {
						return {
							x:di[xColumn],
							y:d.func(di[xColumn])
						}
					}))
					//return line(d.values)
				})
				.style("stroke", function(d) { return colorScale(d[colorColumn])})


			xAxisG.call(xAxis);
			yAxisG.call(yAxis);
			colorLegendG.call(colorLegend);


		}

		render(data)

	</script>

</body>
</html>